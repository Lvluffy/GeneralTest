<resources>
    <string name="app_name">设计模式</string>
    <!--创建型-->
    <string name="design_pattern_create">创建型</string>
    <string name="singleton">单例</string>
    <string name="prototype">原型</string>
    <string name="factory_method">工厂方法</string>
    <string name="abstract_factory">抽象工厂</string>
    <string name="builder">构建者</string>
    <!--结构型-->
    <string name="design_pattern_structure">结构型</string>
    <string name="proxy">代理</string>
    <string name="adapter">适配器</string>
    <string name="bridge">桥接</string>
    <!--行为型-->
    <string name="design_pattern_behavior">行为型</string>
    <!--单例-->
    <string name="singleton_hungry">饿汉式</string>
    <string name="singleton_hungry_desc">特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</string>
    <string name="singleton_lazy">懒汉式</string>
    <string name="singleton_lazy_desc">注意：如果编写的是多线程程序，则不要删除代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。 如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</string>
    <string name="singleton_double_check">双重检查</string>
    <string name="singleton_double_check_desc">优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。 缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。 DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效。</string>
    <string name="singleton_static_inner_class">静态内部类</string>
    <string name="singleton_static_inner_class_desc">类创建的时候不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder并初始化sInstance，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</string>
    <!--原型-->
    <string name="prototype_case_analyze">原型案例分析：用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。</string>
    <string name="prototype_circle_hint">请输入圆的半径</string>
    <string name="prototype_circle_desc">半径为%1$s的圆，它的面积是：%2$s</string>
    <string name="prototype_square_hint">请输入正方形的边长</string>
    <string name="prototype_square_desc">边长为%1$s的正方形，它的面积是：%2$s</string>
    <string name="prototype_rectangle_long_hint">请输入长方形的长</string>
    <string name="prototype_rectangle_wide_hint">请输入长方形的宽</string>
    <string name="prototype_rectangle_desc">长为%1$s宽为%2$s的长方形，它的面积是：%3$s</string>
    <string name="prototype_triangle_end_hint">请输入三角形的底</string>
    <string name="prototype_triangle_high_hint">请输入三角形的高</string>
    <string name="prototype_triangle_desc">底为%1$s高为%2$s的三角形，它的面积是：%3$s</string>
    <!--工厂方法-->
    <string name="factory_method_case_analyze">工厂方法案例分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛</string>
    <string name="factory_method_desc">工厂方法：只考虑同等级产品的生产。例如：畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</string>
    <!--抽象工厂-->
    <string name="abstract_factory_case_analyze">抽象工厂案例分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等。\n1号农场用于养牛和种菜，2号农场用于养马和种水果。</string>
    <string name="abstract_factory_desc">抽象工厂：考虑多等级产品的生产。例如：农场里既养动物又种植物、电器厂既生产电视机又生产洗衣机或空调、大学既有软件专业又有生物专业等。</string>
    <string name="abstract_factory_no1_farm">1号农场</string>
    <string name="abstract_factory_no2_farm">2号农场</string>
    <!--建造者-->
    <string name="builder_case_analyze">建造者案例分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局。</string>
    <string name="builder_no1_decorator">1号装修工</string>
    <string name="builder_no2_decorator">2号装修工</string>
    <!--代理-->
    <string name="proxy_case_analyze">代理案例分析：“山西特产公司”经营许多山西特产，它是真实主题，提供了显示特产的 display() 方法。太原“天街e角”公司是山西特产公司特产的代理，通过调用山西特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“山西特产公司”的产品</string>
    <!--适配器-->
    <string name="adapter_case_analyze">适配器案例分析：新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。</string>
    <string name="adapter_electric_adapter">电能适配器</string>
    <string name="adapter_optical_adapter">光能适配器</string>
    <!--桥接-->
    <string name="bridge_case_analyze">桥接案例分析：模式模拟女士皮包的选购。按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）</string>
    <string name="bridge_yellow_bag">黄色包</string>
    <string name="bridge_red_bag">红色包</string>
</resources>
