<resources>
    <string name="app_name">设计模式</string>
    <!--创建型-->
    <string name="design_pattern_create">创建型</string>
    <string name="singleton">单例</string>
    <string name="prototype">原型</string>
    <string name="factory_method">工厂方法</string>
    <string name="abstract_factory">抽象工厂</string>
    <string name="builder">构建者</string>
    <!--结构型-->
    <string name="design_pattern_structure">结构型</string>
    <string name="proxy">代理</string>
    <string name="adapter">适配器</string>
    <string name="bridge">桥接</string>
    <string name="decorator">装饰者</string>
    <string name="facade">外观</string>
    <string name="flyweight">享元</string>
    <string name="composite">组合</string>
    <!--行为型-->
    <string name="design_pattern_behavior">行为型</string>
    <string name="template_method">模版方法</string>
    <string name="strategy">策略</string>
    <string name="command">命令</string>
    <string name="chain_of_responsibility">责任链</string>
    <string name="status">状态</string>
    <string name="observer">观察者</string>
    <string name="mediator">中介者</string>
    <string name="iterator">迭代器</string>
    <string name="visitor">访问者</string>
    <string name="memento">备忘录</string>
    <string name="interpreter">解释器</string>
    <!--单例-->
    <string name="singleton_hungry">饿汉式</string>
    <string name="singleton_hungry_desc">特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</string>
    <string name="singleton_lazy">懒汉式</string>
    <string name="singleton_lazy_desc">注意：如果编写的是多线程程序，则不要删除代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。 如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</string>
    <string name="singleton_double_check">双重检查</string>
    <string name="singleton_double_check_desc">优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。 缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。 DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效。</string>
    <string name="singleton_static_inner_class">静态内部类</string>
    <string name="singleton_static_inner_class_desc">类创建的时候不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder并初始化sInstance，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</string>
    <!--原型-->
    <string name="prototype_case_analyze">原型案例分析：用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。</string>
    <string name="prototype_circle_hint">请输入圆的半径</string>
    <string name="prototype_circle_desc">半径为%1$s的圆，它的面积是：%2$s</string>
    <string name="prototype_square_hint">请输入正方形的边长</string>
    <string name="prototype_square_desc">边长为%1$s的正方形，它的面积是：%2$s</string>
    <string name="prototype_rectangle_long_hint">请输入长方形的长</string>
    <string name="prototype_rectangle_wide_hint">请输入长方形的宽</string>
    <string name="prototype_rectangle_desc">长为%1$s宽为%2$s的长方形，它的面积是：%3$s</string>
    <string name="prototype_triangle_end_hint">请输入三角形的底</string>
    <string name="prototype_triangle_high_hint">请输入三角形的高</string>
    <string name="prototype_triangle_desc">底为%1$s高为%2$s的三角形，它的面积是：%3$s</string>
    <!--工厂方法-->
    <string name="factory_method_case_analyze">工厂方法案例分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛</string>
    <string name="factory_method_desc">工厂方法：只考虑同等级产品的生产。例如：畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</string>
    <!--抽象工厂-->
    <string name="abstract_factory_case_analyze">抽象工厂案例分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等。\n1号农场用于养牛和种菜，2号农场用于养马和种水果。</string>
    <string name="abstract_factory_desc">抽象工厂：考虑多等级产品的生产。例如：农场里既养动物又种植物、电器厂既生产电视机又生产洗衣机或空调、大学既有软件专业又有生物专业等。</string>
    <string name="abstract_factory_no1_farm">1号农场</string>
    <string name="abstract_factory_no2_farm">2号农场</string>
    <!--建造者-->
    <string name="builder_case_analyze">建造者案例分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局。</string>
    <string name="builder_no1_decorator">1号装修工</string>
    <string name="builder_no2_decorator">2号装修工</string>
    <!--代理-->
    <string name="proxy_case_analyze">代理案例分析：“山西特产公司”经营许多山西特产，它是真实主题，提供了显示特产的 display() 方法。太原“天街e角”公司是山西特产公司特产的代理，通过调用山西特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“山西特产公司”的产品</string>
    <!--适配器-->
    <string name="adapter_case_analyze">适配器案例分析：新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。</string>
    <string name="adapter_electric_adapter">电能适配器</string>
    <string name="adapter_optical_adapter">光能适配器</string>
    <!--桥接-->
    <string name="bridge_case_analyze">桥接案例分析：模式模拟女士皮包的选购。按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）</string>
    <string name="bridge_yellow_bag">黄色包</string>
    <string name="bridge_red_bag">红色包</string>
    <!--装饰-->
    <string name="decorator_case_analyze">装饰案例分析：美女变身。实例中的“美女”原身有 setImage(String t)方法决定其显示方式，而其变身“都市丽人装”和“军旅装”可以用 setChanger() 方法来改变其外观，原身与变身后的效果用 display() 方法来显示</string>
    <string name="decorator_original">原身</string>
    <string name="decorator_city_beauty">都市丽人</string>
    <string name="decorator_military">军旅</string>
    <!--外观-->
    <string name="facade_case_analyze">外观案例分析：山西特产选购。外观角色 SxSpecialty，它拥有 10 个子系统角色Specialty1~Specialty10，它们是图标类（ImageIcon）的子类对象，用来保存该山西特产的图标</string>
    <!--享元-->
    <string name="flyweight_case_analyze">享元案例分析：五子棋游戏中的应用。实例中的棋子（ChessPieces）类是抽象享元角色，它包含了一个落子的 DownPieces(Graphics g,Point pt) 方法；白子（WhitePieces）和黑子（BlackPieces）类是具体享元角色，它实现了落子方法；Point 是非享元角色，它指定了落子的位置；WeiqiFactory 是享元工厂角色，它通过 ArrayList 来管理棋子，并且提供了获取白子或者黑子的 getChessPieces(String type) 方法</string>
    <!--组合-->
    <string name="composite_case_analyze">组合案例分析：用户到生活用品店购物。\n用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；\n用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；\n用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；\n用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。\n要求编程显示用户放在大袋子中的所有商品信息并计算要支付的总价。</string>
    <!--模版方法-->
    <string name="template_method_case_analyze">模版方法案例分析：出国留学手续设计。\n分析：出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。\n在本实例中，我们先定义一个出国留学的抽象类 StudyAbroad，里面包含了一个模板方法 templateMethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 StudyInAmerica）中实现。如果再增加一个国家，只要增加一个子类就可以了。</string>
    <string name="template_method_study_in_america">留学美国</string>
    <!--策略-->
    <string name="strategy_case_analyze">策略案例分析：“大闸蟹”做菜。\n分析：关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例。\n首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 cookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果显示出来。</string>

    <!--责任链-->
    <string name="chain_of_responsibility_case_analyze">请假审批：组长1天；部门主管3天；经理7天；老板30天</string>
    <string name="strategy_steamed">清蒸大闸蟹</string>
    <string name="strategy_braised">红烧大闸蟹</string>

</resources>
